#!/bin/bash
#
# Common Library
#
# Global variables
#
#       debug_off=true|false
#
#       dry_run=true|false
#
#

# TODO consolidate with ec2.shlib similar function
# By default, without doing anything, debug is turned off.
# To turn debugging on, set debug_off=false somewhere in the upper calling layers.
function debug
{
    ${debug_off} && return 0
    echo "$1" 1>&2;
}

# TODO consolidate with ec2.shlib similar function
function info()
{
    echo "$@" 1>&2;
}

# TODO consolidate with ec2.shlib similar function
# sends the arguments at stderr and exits with 1
function fail()
{
    echo "$@" 1>&2;
    exit 1
}


function get-ids
{
    ids=$(cat /etc/hosts | grep -v localhost | grep -v "^ *$" | sed -e 's/^.* \(.*\)$/\1/')
    echo ${ids}
}

# fails if the id does not exist
function id-to-ip
{
    local id=$1

    [ "${id}" = "" ] && { echo "'id' is not set" 1>&2; exit 1; }

    local line
    line=$(cat /etc/hosts | grep "^.* ${id}$")
    line=${line%% *}
    [ "${line}" = "" ] && { echo "id ${id} not known" 1>&2; exit 1; }
    echo ${line}
}

# returns our eth0 address
function get-ip-address
{
    local ip
    ip=$(ifconfig eth0 | grep "inet ") || { exit 1; }
    ip=${ip#*inet }
    ip=${ip%% *}
    ip=${ip#addr:}
    [ "${ip}" = "" ] && { echo "failed to figure out the IP address" 1>&2; exit 1; }
    echo ${ip}
}

# returns the group owner of the directory/file or fails with a return code 1
function get-group
{
    local target=$1
    local s

    if [ -f ${target} ]; then
        s=$(ls -l ${target})
    elif [ -d ${target} ]; then
        s=$(ls -ld ${target})
    else
        echo "failed to figure out group for ${target}" 1>&2;
        return 1
    fi

    echo ${s} | awk '{print $4}'
}

#######################################################################################
# Host-wide configuration
#######################################################################################


#
# This is the function that links the id to ec2-host in /nfs/bin, providing for the shortcut to
# ssh into the host
#
function link-to-ec2-host
{
    local id=$1
    local bin_dir=$2
    [ "${id}" = "" ] && { echo "'id' not specified" 1>&2; exit 1; }
    [ "${bin_dir}" = "" ] && { echo "'bin_dir' not provided" 1>&2; exit 1; }
    [ ! -d ${bin_dir} ] && { echo "'bin_dir' ${bin_dir} not a directory" 1>&2; exit 1; }
    [ -x ${bin_dir}/ec2-host ] || { echo "${bin_dir}/ec2-host does not exist or is not executable. Have you configured and started the NFS client?" 1>&2; exit 1; }

    if [ ! -h ${bin_dir}/${id} ]; then
        (cd ${bin_dir}; ln -s ./ec2-host ${id}) && echo "linked ${id} to ${bin_dir}/ec2-host"
    fi
}

#######################################################################################
# User Environment Configuration
#######################################################################################

function get-home-dir
{
    local user_name=$1
    debug "setup-bashrc(user_name=$1)"
    [ "${user_name}" = "" ] && { echo "'user_name' not specified" 1>&2; exit 1; }

    local home_dir

    if [ "${user_name}" = "root" ]; then
        home_dir="/root"
    else
        home_dir="/home/${user_name}"
    fi

    [ -d ${home_dir} ] || { echo "home directory for user ${user_name} ${home_dir} does not exist" 1>&2; exit 1; }

    echo "${home_dir}"
}

#
# assumes the correct hostname is returned by 'hostname' so setup-hostname must be
# run before this
#
function setup-bashrc
{
    local user_name=$1
    debug "setup-bashrc(user_name=$1)"
    [ "${user_name}" = "" ] && { echo "'user_name' not specified" 1>&2; exit 1; }

    local hostname
    hostname=$(hostname) || { echo "failed to execute hostname" 1>&2; exit 1; }

    local cursor=">"
    [ "${user_name}" = "root" ] && cursor="#"

    local PS1_content="export PS1=\"${user_name}@${hostname}${cursor} \""

    local bashrc_file="$(get-home-dir ${user_name})/.bashrc"

    if ! grep -q "${PS1_content}" ${bashrc_file}; then
        echo "" >> ${bashrc_file}
        echo "${PS1_content}" >> ${bashrc_file}
        echo "PS1 configured in ${bashrc_file}"
    fi

    local alias_content="alias h='history'"

    if ! grep -q "${alias_content}" ${bashrc_file}; then
        echo "" >> ${bashrc_file}
        echo "${alias_content}" >> ${bashrc_file}
        echo "${alias_content} configured in ${bashrc_file}"
    fi

    alias_content="alias r='sudo su -'"

    if ! grep -q "${alias_content}" ${bashrc_file}; then
        echo "${alias_content}" >> ${bashrc_file}
        echo "${alias_content} configured in ${bashrc_file}"
    fi

    alias_content="alias cds='cd /nfs'"

    if ! grep -q "${alias_content}" ${bashrc_file}; then
        echo "${alias_content}" >> ${bashrc_file}
        echo "${alias_content} configured in ${bashrc_file}"
    fi

    local gld_home_content="export GLD_HOME=/nfs/gld/current"

    if ! grep -q "${gld_home_content}" ${bashrc_file}; then
        echo "" >> ${bashrc_file}
        echo "${gld_home_content}" >> ${bashrc_file}
        echo "export PATH=\${PATH}:\${GLD_HOME}/bin" >> ${bashrc_file}
        echo "${gld_home_content} configured in ${bashrc_file}"
    fi
}

function update-bashrc-with-java-information
{
    local user=$1
    local java_home=$2

    debug "updating .bashrc with java information ..."

    [ "${user}" = "" ] && { echo "'user' not provided" 1>&2; exit 1; }
    [ "${java_home}" = "" ] && { echo "'java_home' not provided" 1>&2; exit 1; }
    [ -d "${java_home}" ] || { echo "'java_home' ${java_home} does not exist" 1>&2; exit 1; }
    [ -d "${java_home}/bin" ] || { echo "'java_home'/bin ${java_home}/bin does not exist" 1>&2; exit 1; }

    local bashrc_file="$(get-home-dir ${user})/.bashrc"

    if ! grep -q "export JAVA_HOME=${java_home}" ${bashrc_file}; then
        echo "" >> ${bashrc_file}
        echo "export JAVA_HOME=${java_home}" >> ${bashrc_file}
        echo "export PATH=\${JAVA_HOME}/bin:\${PATH}" >> ${bashrc_file}
        echo "java information configured in ${bashrc_file}"
    fi
}

function setup-environment-private-key
{
    local user_name=$1
    local environment_private_key_file=$2
    debug "setup-environment-private-key(user_name=$1, environment_private_key_file=$2)"
    [ "${user_name}" = "" ] && { echo "'user_name' not specified" 1>&2; exit 1; }
    [ "${environment_private_key_file}" = "" ] && { echo "'environment_private_key_file' not specified" 1>&2; exit 1; }
    [ -f "${environment_private_key_file}" ] || { echo "'environment_private_key_file' ${environment_private_key_file} does not exist" 1>&2; exit 1; }

    local ssh_dir=$(get-home-dir ${user_name})/.ssh

    if [ ! -d ${ssh_dir} ]; then
        mkdir ${ssh_dir} || exit 1
        chown ${user_name}:${user_name} ${ssh_dir} || exit 1
        echo "created ${ssh_dir}"
    fi

    if [ ! -f ${ssh_dir}/id_rsa ]; then
        cat ${environment_private_key_file} >> ${ssh_dir}/id_rsa || { echo "failed to copy environment key file into ${ssh_dir}/id_rsa" 1>&2; exit 1; }
        chown ${user_name}:${user_name} ${ssh_dir}/id_rsa || exit 1
        chmod go-rwx ${ssh_dir}/id_rsa || exit 1
        echo "created ${ssh_dir}/id_rsa"
    fi
}

function setup-environment-public-key
{
    local user_name=$1
    local environment_private_key_file=$2
    debug "setup-environment-private-key(user_name=$1, environment_private_key_file=$2)"
    [ "${user_name}" = "" ] && { echo "'user_name' not specified" 1>&2; exit 1; }
    [ "${environment_private_key_file}" = "" ] && { echo "'environment_private_key_file' not specified" 1>&2; exit 1; }
    [ -f "${environment_private_key_file}" ] || { echo "'environment_private_key_file' ${environment_private_key_file} does not exist" 1>&2; exit 1; }

    local ssh_dir=$(get-home-dir ${user_name})/.ssh

    if [ ! -d ${ssh_dir} ]; then
        mkdir ${ssh_dir} || exit 1
        chown ${user_name}:${user_name} ${ssh_dir} || exit 1
        echo "created ${ssh_dir}"
    fi

    local key_label="environment-access-key"

    if ! grep -q "${key_label}" ${ssh_dir}/authorized_keys; then
        local public_key
        public_key=$(ssh-keygen -y -f ${environment_private_key_file}) || \
            { echo "failed to generate public key from ${environment_private_key_file}" 1>&2; exit 1; }
        public_key="${public_key} ${key_label}"
        echo ${public_key} >> ${ssh_dir}/authorized_keys || { echo "failed to copy environment key file into ${ssh_dir}/id_rsa" 1>&2; exit 1; }
        chown ${user_name}:${user_name} ${ssh_dir}/id_rsa || exit 1
        echo "updated ${ssh_dir}/authorized_keys, added '${key_label}'"
    fi
}

function setup-ovidiu-defaut-public-key
{
    local ovidiu_default_file=$1
    [ "${ovidiu_default_file}" = "" ] && { echo "'ovidiu_default_file' not specified" 1>&2; exit 1; }
    [ -f "${ovidiu_default_file}" ] || { echo "'ovidiu_default_file' ${ovidiu_default_file} does not exist" 1>&2; exit 1; }

    local ssh_dir=$(get-home-dir ec2-user)/.ssh

    if ! grep -q "ovidiu_default" ${ssh_dir}/authorized_keys; then
        cat ${ovidiu_default_file} >> ${ssh_dir}/authorized_keys || { echo "failed to copy ${ovidiu_default_file} into ${ssh_dir}/id_rsa" 1>&2; exit 1; }
        echo "updated ${ssh_dir}/authorized_keys, added 'ovidiu_default'"
    fi
}

#######################################################################################
# Storage
#######################################################################################

function mount-main-storage
{
    local mount_point=$1
    local partition=$2

    [ "${mount_point}" = "" ] && { echo "'mount_point' not specified" 1>&2; exit 1; }

    #
    # determine wheteher fstab is already set up
    #

    if ! grep -q "^.* *${mount_point} *ext4.*$" /etc/fstab; then

        #
        # fstab not configured
        #

        unmounted_device_count=$(lsblk -l | grep "part *$" | wc -l) || exit 1

        # the only case we're handling is when we only have an unmounted device or
        # --partition is specified; anything else is an error

        local device_name

        if [ "${unmounted_device_count}" = "0" ]; then

            # all devices are mounted, but we still need to make sure that the ${mount_point} subdir exist
            device_name=$(lsblk -l | grep "${mount_point}") || exit 1
            device_name="/dev/${device_name%% *}"

        elif [ "${partition}" != "" ]; then

            device_name="/dev/${partition}"

        elif [ "${unmounted_device_count}" = "1" ]; then

            device_name=$(lsblk -l | grep "part *$")
            device_name=${device_name%% *}
            device_name="/dev/${device_name}"

        else
            echo "unmounted_device_count: '${unmounted_device_count}'";
            echo ""
            echo "unmounted devices:"
            echo ""
            lsblk -l | grep "part *$"
            echo ""
            echo "specify the one you want to use with '--partition' and try again"
            echo ""
            exit 1;
        fi

        device_type=$(file -s ${device_name})
        device_type=${device_type#*: }

        echo "device_name: ${device_name}, ${device_type}: ${device_type}"
        return 0

        #
        # determine whether we need to create a file system
        #

        if [ "${device_type}" == "data" ]; then
            # the device does not have a filesystem on it, it does need formatting
            mkfs -t ext4 ${device_name} && echo "created ext4 filesystem on ${device_name}" || \
                { echo "failed to create filesystem on ${device_name}"; exit 1; }
        fi

        # update /etc/fstab
        echo "${device_name}       /data   ext4    defaults,nofail        0       2" >> /etc/fstab && \
        echo "declared ${device_name} in /etc/fstab"

    else

        #
        # fstab is configured
        #

        if [ ! -d /data ]; then
            mkdir /data && echo "created mountpoint /data"
            chgrp ec2-user /data
            chmod g+w /data
        fi

        mount -a

        #
        # make sure the filesystem is mounted
        #

        count=$(mount | grep "on /data " | wc -l)

        if [ "${count}" != "1" ]; then
            echo ""
            echo "/data does not seem to be mounted correctly, count ${count}:"
            echo ""
            mount
            exit 1
        fi
    fi

    return 0

    if [ ! -d /data/archive ]; then
        mkdir /data/archive && echo "created /data/archive"
        chgrp ec2-user /data/archive
        chmod g+w /data/archive
    fi

    if [ ! -d /data/bin ]; then
        mkdir /data/bin && echo "created /data/bin"
        chgrp ec2-user /data/bin
        chmod g+w /data/bin
    fi
}


#######################################################################################
# NFS Installation
#######################################################################################

function setup-nfs-server
{
    install-package rpcbind
    install-package nfs-utils

    #
    # share /data in /etc/exports
    #

    if ! grep -q "^/data " /etc/exports; then
        echo "/data 172.31.16.0/20(rw,sync,no_root_squash,no_subtree_check)" >> /etc/exports && echo "declared /data in /etc/exports"
    fi

    if ! systemctl -q is-enabled nfs-server; then
        systemctl enable nfs-server
        echo "nfs server enabled for boot"
    fi

    if ! systemctl -q is-active nfs-server; then
        service nfs-server start
        echo "nfs server started"
    fi

    exportfs -a || { echo "failed to exportfs" 1>&2; exit 1; }
}

#######################################################################################
# Java
#######################################################################################

# return the absolute path of the sole Java directory, or empty string if no java directory
# is found, or fail if more than one java directory is found
function get_java_dir
{
    local parent=$1

    [ "${parent}" = "" ] && { echo "'parent' directory not specified" 1>&2; exit 1; }
    [ -d ${parent} ] || { echo "'parent' ${parent} is not a directory" 1>&2; exit 1; }

    local java_dir

    for i in $(ls -d ${parent}/*); do
        if [ -d ${i} ]; then
            local name
            name=$(basename ${i})
            name=${name:0:3}
            if [ "${name}" = "jdk" ]; then
                [ "${java_dir}" != "" ] && { echo "more than one java directory exist in ${parent}: ${java_dir}, ${i}" 1>&2; exit 1; }
                java_dir=${i}
            fi
        fi
    done

    echo ${java_dir}
}

# returns the installed java director
function install_java
{
    local java_archive_name=$1
    local archive_dir=$2
    debug "installing java ..."
    [ "${archive_dir}" = "" ] && { echo "'archive_dir' not provided" 1>&2; exit 1; }
    [ -d "${archive_dir}" ] || { echo "'archive_dir' ${archive_dir} does not exist" 1>&2; exit 1; }

    local java_archive_file=${archive_dir}/${java_archive_name}
    [ -f ${java_archive_file} ] || { echo "java archive file ${java_archive_file} does not exist" 1>&2; exit 1; }

    [ -h /opt/java ] && { echo "java already installed"; return 0; }

    debug "extracting java from ${java_archive_file} into /opt ..."

    (cd /opt; gunzip < ${java_archive_file} | tar xf -) && echo "extracted java into /opt" 1>&2 || { echo "failed to extract java" 1>&2; exit 1; }

    local java_dir
    java_dir=$(get_java_dir /opt) || exit 1

    ln -s ${java_dir} /opt/java && echo "linked ${java_dir} to /opt/java" 1>&2
}

