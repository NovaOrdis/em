#!/bin/bash

function list-em-commands()
{
    local command_dir=$(dirname $0)/commands
    [ -d ${command_dir} ] || fail "command directory ${command_dir} not found"

    commands=$(ls ${command_dir})
    excludes="lib lifecycle"
    for i in ${commands}; do
        [[ "${excludes}" =~ ${i} ]] && continue;

        echo "    ${i}"
    done
}

function read-bootstrap-configuration()
{
    debug-arguments $@

    local bootstrap_conf_file=$(dirname $0)/../etc/bootstrap.conf
    [ -f ${bootstrap_conf_file} ] && . ${bootstrap_conf_file} || warn "bootstrap configuration file ${bootstrap_conf_file} not found"
}

#
# function reads user-specific configuration. A side effect is creating the user-specific em directory (~/.ec) and
# the internal directory structure
#
function read-user-configuration()
{
    debug-arguments $@

    local dir

    if [ ! -d ${HOME}/.em ]; then
        debug "creating the user .em directory and associated structures"
        dir=${HOME}/.em; mkdir ${dir} && debug "created ${dir}" || fail "failed to create ${dir}"
        dir=${HOME}/.em/bin; mkdir ${dir} && debug "created ${dir}" || fail "failed to create ${dir}"
    elif [ ! -d ${HOME}/.em/bin ]; then
        # this is in case the bin directory was deleted by mistake
        dir=${HOME}/.em/bin; mkdir ${dir} && debug "created ${dir}" || fail "failed to create ${dir}"
    fi

    # TODO - read configuration
}

########################################################################################################################
# environment configuration tools
########################################################################################################################

environment_configuration_file_sourced=false

#
# we access environment configuration through a function because we want to be isolate the client code from
# changes in access to it
#
# Always returns a non-zero-length string containing the environment configuration value at stdout. If the variable
# is not defined or defined as an enpty string, the function fails with a human readable error message. The function
# also fails on any error while trying to resolve the variable. TODO: refactor if empty variable values are legal
#
# The method performs all necessary debug logging.
#
# Recommended usage pattern
#
# local myvar
# myvar=$(get-environment-configuration "myvar") || exit 1
# # guaranteed non-zero-lenght value
#
function get-environment-configuration()
{
    debug-arguments $@

    local env_config_var_name=$1
    [ -z ${env_config_var_name} ] && fail "the environment configuration variable name not provided"

    if ! ${environment_configuration_file_sourced}; then
        #
        # if ENVIRONMENT_CONFIGURATION_FILE is defined and accessible, source it to have access to the enviornment
        # configuratiom. This only can happen if NFS is operational
        #
        [ -z ${ENVIRONMENT_CONFIGURATION_FILE} ] && fail "environment configuration file not defined, check your bootstrap configuration"
        [ -f ${ENVIRONMENT_CONFIGURATION_FILE} ] || fail "environment configuration file ${ENVIRONMENT_CONFIGURATION_FILE} not accessible"
        . ${ENVIRONMENT_CONFIGURATION_FILE} && { debug "sourced ${ENVIRONMENT_CONFIGURATION_FILE}"; } || fail "failed to source ${ENVIRONMENT_CONFIGURATION_FILE}"

        environment_configuration_file_sourced=true
    fi

    local value=${!env_config_var_name}
    debug "environment variable ${env_config_var_name} resolved to \"${value}\""
    [ -z ${value} ] && fail "'${env_config_var_name}' environemnt configuration variable not defined in ${ENVIRONMENT_CONFIGURATION_FILE}"
    echo "${value}"
}
