#!/bin/bash

#
# Successful installation exports a valid JBOSS_HOME in the environment.
#
# return 0 if the installation modified state or 1 if not
#
function install-binaries() {

    debug-arguments $@

    local repository
    repository=$(get-environment-configuration "repository") || exit 1
    [ -d ${repository} ] || fail "repository directory ${repository} not accessible"

    local eap_template_name
    eap_template_name=$(get-environment-configuration "eap_template") || exit 1

    local eap_template_file=${repository}/${eap_template_name}
    [ -f ${eap_template_file} ] || fail "EAP template file ${eap_template_file} not found"

    local top_level_dir_in_archive
    top_level_dir_in_archive=$(get-top-level-dir-in-zip-archive ${eap_template_file}) || \
        fail "failed to get the top level dir from archive ${eap_template_file}"

    if [ -d /opt/${top_level_dir_in_archive} ]; then
        debug "EAP already installed (/opt/${top_level_dir_in_archive})"
        [ ! -h /opt/eap ] && fail "EAP already installed as /opt/${top_level_dir_in_archive} but /opt/eap link not created"
        export JBOSS_HOME=/opt/eap
        return 1;
    fi

    info "installing EAP ..."

    local unzip_quiet="-q"
    ${verbose} && unzip_quiet=""

    info "extracting ${eap_template_file} into /opt ..."
    (cd /opt; unzip ${unzip_quiet} ${eap_template_file}) && \
        info "extracted ${eap_template_file} into /opt" || \
        fail "failed to extract ${eap_template_file} into /opt"

    top_level_dir_in_archive="/opt/${top_level_dir_in_archive}"
    debug "dir_name: ${top_level_dir_in_archive}"
    [ -d ${top_level_dir_in_archive} ] || fail "${top_level_dir_in_archive} not a directory"

    (cd /opt; ln -s $(basename ${top_level_dir_in_archive}) eap) && \
        info "linked $(basename ${top_level_dir_in_archive}) to /opt/eap" || \
        fail "failed to link $(basename ${top_level_dir_in_archive}) to /opt/eap"

    export JBOSS_HOME=/opt/eap
    debug "exported JBOSS_HOME=${JBOSS_HOME}"
    return 0
}

# return 0 if the function changed state or 1 if not
function update-user-environment-for-eap()
{
    debug-arguments $@

    local user=$1
    [ "${user}" = "" ] && fail "${FUNCNAME[0]}: 'name' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -d ${JBOSS_HOME} ] || fail "${JBOSS_HOME} does not exist"

    local state_changed=false

    local bashrc_file="$(get-home ${user})/.bashrc"

    debug ".bashrc file: ${bashrc_file}"

    if ! grep -q "^export JBOSS_HOME=${JBOSS_HOME}" ${bashrc_file}; then
        echo "export JBOSS_HOME=${JBOSS_HOME}" >> ${bashrc_file}
        info "JBOSS_HOME set for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jb=" ${bashrc_file}; then
        echo "alias jb='cd \${JBOSS_HOME}'" >> ${bashrc_file}
        info "'jb' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbb=" ${bashrc_file}; then
        echo "alias jbb='cd \${JBOSS_HOME}/bin'" >> ${bashrc_file}
        info "'jbb' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbc=" ${bashrc_file}; then
        echo "alias jbc='cd \${JBOSS_HOME}/domain/configuration'" >> ${bashrc_file}
        info "'jbc' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbl=" ${bashrc_file}; then
        echo "alias jbl='cd \${JBOSS_HOME}/domain/log'" >> ${bashrc_file}
        info "'jbc' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbprocs=" ${bashrc_file}; then
        echo "alias jbprocs='ps -ef | grep java | grep --color \"\-D\[.*\]\"'" >> ${bashrc_file}
        info "'jbprocs' alias created for user ${user}"
        state_changed=true
    fi

    ${state_changed} && return 0 || return 1
}

# return 0 if the function changed state or 1 if not
function add-a-management-user()
{
    debug-arguments $@

    local management_user_name=$1
    local management_user_password=$2
    [ -z "${management_user_name}" ] && fail "${FUNCNAME[0]}: 'management_user_name' not provided"
    [ -z "${management_user_password}" ] && fail "${FUNCNAME[0]}: 'management_user_password' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -d ${JBOSS_HOME} ] || fail "${JBOSS_HOME} does not exist"

    local state_changed=false

    #
    # relax password strength enforcement
    #
    if grep -q "^password.restriction=REJECT" ${JBOSS_HOME}/bin/add-user.properties; then
        replace-regex "^password.restriction=REJECT" "password.restriction=WARN" ${JBOSS_HOME}/bin/add-user.properties || exit 1
        info "relaxed password restrictions for add-user.sh"
        state_changed=true
    fi

    #
    # add a management user
    #
    if ! grep -q "^${management_user_name}=" ${JBOSS_HOME}/standalone/configuration/mgmt-users.properties || ! grep -q "^${management_user_name}=" ${JBOSS_HOME}/domain/configuration/mgmt-users.properties; then
        ${JBOSS_HOME}/bin/add-user.sh -r ManagementRealm -u ${management_user_name} -p "${management_user_password}" || \
            fail "failed to execute ${JBOSS_HOME}/bin/add-user.sh"
        # no need for info, add-user.sh reports at stdout
        state_changed=true
    fi

    ${state_changed} && return 0 || return 1
}

# return 0 if the function changed state or 1 if not
function configure-public-interface()
{
    local ip=$1

    debug-arguments $@

    [ -z "${ip}" ] && fail "${FUNCNAME[0]}: 'ip' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    #
    # this code configures a host controller, if we need to configure a standalone node, we must refactor
    #

    local domain_conf_file=${JBOSS_HOME}/bin/domain.conf
    [ -f ${domain_conf_file} ] || fail "${domain_conf_file} does not exist"

    if ! grep -q "^HOST_CONTROLLER_JAVA_OPTS=.*Djboss\.bind\.address=" ${domain_conf_file}; then
        echo "" >> ${domain_conf_file}
        echo "HOST_CONTROLLER_JAVA_OPTS=\"\${HOST_CONTROLLER_JAVA_OPTS} -Djboss.bind.address=${ip}\"" >> ${domain_conf_file}
        info "configured public interface to bind to ${ip}"
    fi
}

# return 0 if the function changed state or 1 if not
function configure-management-interface()
{
    debug-arguments $@

    local ip=$1

    [ -z "${ip}" ] && fail "${FUNCNAME[0]}: 'ip' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    #
    # this code configures a host controller, if we need to configure a standalone node, we must refactor
    #

    local domain_conf_file=${JBOSS_HOME}/bin/domain.conf
    [ -f ${domain_conf_file} ] || fail "${domain_conf_file} does not exist"

    if ! grep -q "^HOST_CONTROLLER_JAVA_OPTS=.*Djboss\.bind\.address\.management=" ${domain_conf_file}; then
        echo "" >> ${domain_conf_file}
        echo "HOST_CONTROLLER_JAVA_OPTS=\"\${HOST_CONTROLLER_JAVA_OPTS} -Djboss.bind.address.management=${ip}\"" >> ${domain_conf_file}
        info "configured management interface to bind to ${ip}"
        return 0
    fi

    return 1
}

#
# TODO: replace modifying xml with external property (jboss.host.name)
#
# return 0 if the function changed state or 1 if not
function configure-host.xml-host-name() {

    debug-arguments $@

    local host_name=$1

    [ -z "${host_name}" ] && fail "${FUNCNAME[0]}: 'host_name' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local host_conf_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_conf_file} ] || fail "${host_conf_file} does not exist"

    if ! grep -q "^<host name=\"${host_name}\" " ${host_conf_file}; then
            replace-regex "^\(<host name=\\\"\).*\(\\\" xmlns=.*\)" "\1"${host_name}"\2" ${host_conf_file} || exit 1
        info "set host.xml host name to '${host_name}'"
        return 0
    fi

    return 1
}

function configure-server-groups() {

    debug-arguments $@

    #
    # just a hack now, reduce the memory size so we can start it on small Amazon EC2 instances
    #

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local domain_xml_file=${JBOSS_HOME}/domain/configuration/domain.xml
    [ -f ${domain_xml_file} ] || fail "${domain_xml_file} does not exist"

    local size=200m

    if ! grep -q "<heap size=\"${size}\"" ${domain_xml_file}; then
        replace-regex "^\(.*\)<heap size=.*$" "\1<heap size=\\\""${size}"\\\" max-size=\\\""${size}"\\\"\/>" ${domain_xml_file} || exit 1
        info "updated ${domain_xml_file}"
        return 0
    fi

    return 1
}

#
# configure the "servers" definition in host.xml
#
# return 0 if the function changed state or 1 if not
function configure-servers() {

    debug-arguments $@

    local server_count=$1

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_xml_file} ] || fail "${host_xml_file} does not exist"
    [ -z "${server_count}" ] && fail "no server count specified"

    local changes=false


    #
    # make a copy of the original file, unless it already exists
    #

    if ! ls $(dirname ${host_xml_file})/$(basename ${host_xml_file})-* 2>/dev/null 1>&2; then
        #
        # backup file does not exist
        #
        local extension=$(date +'%y.%m.%d.%H.%M.%S')
        if cp ${host_xml_file} $(dirname ${host_xml_file})/$(basename ${host_xml_file})-${extension}; then
            info "backed up ${host_xml_file} as $(basename ${host_xml_file})-${extension}"
            changes=true
        fi
    fi

    #
    # currently just a hack now, eliminate all servers
    #

    if [ "${server_count}" = "0" ]; then

        local line_number_from
        line_number_from=$(grep -n "<servers>" ${host_xml_file}) || fail "did not find <servers> in ${host_xml_file}"
        line_number_from=${line_number_from%%:*}
        line_number_from=$(expr ${line_number_from} + 1)

        local line_number_to
        line_number_to=$(grep -n "</servers>" ${host_xml_file}) || fail "did not find </servers> in ${host_xml_file}"
        line_number_to=${line_number_to%%:*}
        line_number_to=$(expr ${line_number_to} - 1)

        if [ ${line_number_from} -le ${line_number_to} ]; then
            # there are lines to delete
            local tmp=$(unique-file)
            sed ${line_number_from}','${line_number_to}'d' ${host_xml_file} > ${tmp}
            diff ${host_xml_file} ${tmp} > /dev/null && { rm ${tmp}; debug "no deletion occurred in ${host_xml_file}"; return 1; }
            mv ${tmp} ${host_xml_file} || fail "failed to restore ${host_xml_file}"
            info "edited <servers> section in ${host_xml_file}"
            changes=true
        fi
    else
        fail "non-zero server count not implemented yet"
    fi

    ${changes} && return 0 || return 1
}

#
# The function configures the local host.xml with the IP address of the domain controller
#
function configure-master-domain-controller-locally() {

    debug-arguments $@

    local domain_controller_ip_address=$1
    [ -z "${domain_controller_ip_address}" ] && fail "'domain_controller_ip_address' not provided"
    local domain_controller_name=$2 # this is used for friendlier info messages only
    [ -z "${domain_controller_name}" ] && fail "'domain_controller_name' not provided"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_xml_file} ] || fail "${host_xml_file} does not exist"

    if grep -q "^ *<remote host=\""${domain_controller_ip_address} ${host_xml_file}; then
        info "host controller already configured as a subordinate of domain controller ${domain_controller_name} (${domain_controller_ip_address})"
        return 1
    fi

    #
    # TODO - if we need to change the domain controller IP address
    #
    if grep -q "^ *<remote host=" ${host_xml_file}; then
        fail "this subordinate host controller was already configured with a domain controller different than ${domain_controller_ip_address} - we don't handle this case yet"
    fi

    info "configuring ourselves as subordinate host controller for domain controller ${domain_controller_ip_address}"

    local changes=false

    #
    # comment out "<local/>
    #
    if grep -q "^ *<local/> *$" ${host_xml_file}; then
        replace-regex "<local\/>" "<!-- <local\/> -->" ${host_xml_file} || exit 1
        info "turned off the <local/> domain controller in ${host_xml_file}"
        changes=true
    fi

    #
    # enable the remote domain controller
    #
    if grep -q "<!-- *<remote host" ${host_xml_file}; then
        replace-regex "^\( *\)<!-- *<remote host.*$" "\1<remote host=\\\""${domain_controller_ip_address}"\\\" port=\\\"\${jboss.domain.master.port:9999}\\\" security-realm=\\\"ManagementRealm\\\"\/>" ${host_xml_file} || exit 1
        info "configured domain controller IP address ${domain_controller_ip_address} in ${host_xml_file}"
        changes=true
    fi

    ${changes} && return 0 || return 1
}

function establish-subordinate-host-controller-identity-on-domain-controller() {

    debug-arguments $@

    local domain_controller_ip_address=$1
    local domain_controller_name=$2

    [ -z "${domain_controller_ip_address}" ] && fail "'domain_controller_ip_address' not provided"
    [ -z "${domain_controller_name}" ] && fail "'domain_controller_name' not provided"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -z ${JAVA_HOME} ] && fail "previous steps failed to export JAVA_HOME"

    local host_controller_name=$(hostname)
    local password="${host_controller_name}_123"

    #
    # Unsafe assumption: we assume EAP is installed in the same location on the domain controller so
    # we use the same JBOSS_HOME. This is most likely true, as we strive for homogeneous environments
    # but it may not be. If that is the case, we need to invoke remotely into the domain controller's
    # management interface using the local CLI and get the installation directory
    #

    #
    # Another unsafe assumption: we assume Java is installed in the same location. Same considerations
    # as the above apply.
    #

    local remote_jboss_home=${JBOSS_HOME}
    local remote_java_home=${JAVA_HOME}
    local remote_command="export JAVA_HOME=${remote_java_home}; ${remote_jboss_home}/bin/add-user.sh -r ManagementRealm -u ${host_controller_name} -p ${password}"
    local output
    output=$(execute-remotely "root" ${domain_controller_ip_address} ${remote_command}) || exit 1
    debug "remote execution output: ${output}"

    local server_identity_secret_value=$(compute-server-identity-secret-value ${password})
    debug "server_identity_secret_value: ${server_identity_secret_value}"

    #
    # Update host.xml with the server identity secret value. We can't CLI for the time being, server not up
    # at this point
    #
    # jboss-cli "/host=${host_controller_name}/core-service=management/security-realm=ManagementRealm/server-identity=secret:add(value=\""${server_identity_secret_value}"\")"
    #

    #
    # We have to modify host.xml directly instead ...
    #

    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml

    [ -f ${host_xml_file} ] || fail "${host_xml_file} not found"

    if ! grep -q "${server_identity_secret_value}" ${host_xml_file}; then

        #
        # injecting server identity secret value
        #

        local line_nr
        line_nr=$(grep -n -m 1 "<\/authorization>" ${host_xml_file})
        line_nr=${line_nr%%:*}
        debug "line_nr: ${line_nr}"
        local tmp=$(unique-file)
        cat ${host_xml_file} | sed -e ${line_nr}'a\
                <server-identities>\
                    <secret value="'${server_identity_secret_value}'"/>\
                </server-identities>' > ${tmp}
        mv ${tmp} ${host_xml_file} && \
            info "inserted server identity into ${host_xml_file}" || \
            fail "failed to restore ${host_xml_file}"
    fi
}

#
# gets a topology string
# (<server-group-name1>:<server-name1>,<server-name2>,...;<server-group-name2>:<server-name3>,<server-name4>;...) and
# updates host.xml with the topology, after verifying that the server groups exist on the domain controller.
#
# empty topology string is permitted, it means: remove existing topology
#
function configure-topology() {

    debug-arguments $@

    local domain_controller_ip_address=$1 # empty domain controller is OK if the topology is empty
    local topology=$2 # empty topology is permitted

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local existing_servers
    existing_servers=$(get-existing-servers-from-host-xml)
    debug "existing_servers: ${existing_servers}"

    local added_servers

    if [ -n "${topology}" ]; then

        [ -z "${domain_controller_ip_address}" ] && fail "'domain_controller_ip_address' not provided"

        #
        # we want to add servers
        #

        local server_groups

        server_groups=$(get-server-groups-from-topology-string ${topology}) || exit 1

        local added_servers

        #
        # add the requested server groups
        #

        for sg in ${server_groups}; do

            debug "processing topology server group ${sg}"

            #
            # check if the server group exists on the domain controller
            #

            if ! is-valid-server-group-on-domain-controller ${domain_controller_ip_address} ${sg}; then
                fail "${sg} is not a valid server group on the domain controller"
            fi

            local server_names=$(get-servers-for-group ${sg} ${topology}) || exit 1

            debug "adding servers ${server_names} to server group ${sg}"

            for sn in ${server_names}; do
                debug "server name: ${sn} server group name: ${sg}"
                add-server ${sn} ${sg}
                added_servers="${added_servers} ${sn}:${sg}"
            done
        done

        debug "added_servers: ${added_servers}"
    fi

    #
    # remove the extra servers
    #
    local servers_to_remove

    for es in ${existing_servers}; do
        local added=false
        for as in ${added_servers}; do
            if [ "${es}" = "${as}" ]; then
                added=true;
                break;
            fi
        done

        if ! ${added}; then
            servers_to_remove="${servers_to_remove} ${es}"
        fi
    done

    debug "servers_to_remove: ${servers_to_remove}"

    remove-servers ${servers_to_remove}
}

function get-existing-servers-from-host-xml() {

    debug-arguments $@

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_xml_file} ] || fail "host.xml file ${host_xml_file} not found"
    cat ${host_xml_file} | grep "^ *<server name=\".*\" group=\".*\".*>.*" | sed -e 's/.*name=\"\(.*\)\" group=\"\([^ ]*\)\".*$/\1:\2 /'
}

#
# will return 0 if the server group is valid (exists on the domain controller) or 1 if the server group does not exist
# on the domain controller
#
function is-valid-server-group-on-domain-controller() {

    local domain_controller_ip_address=$1
    local server_group=$2

    local output=$(jboss-cli "ls /server-group" ${domain_controller_ip_address}:9999 "admin" "admin123") || exit 1
    local server_groups=$(echo ${output} | sed -e 's/^.*ls \/server-group \(.*\) \[.*$/\1/') || exit 1
    debug "server_groups: ${server_groups}"
    local sg
    for sg in ${server_groups}; do
        [ "${sg}" = "${server_group}" ] && { debug "${server_group} is a valid server group"; return 0; }
    done
    debug "${server_group} is NOT a valid server group"
    return 1
}

#
# Add server name/server group to host.xml if it does not exist already
#
function add-server() {

    debug-arguments $@

    local server_name=$1
    local server_group=$2

    [ -z "${server_name}" ] && fail "'server_name' not provided"
    [ -z "${server_group}" ] && fail "'server_group' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml

    [ -f ${host_xml_file} ] || fail "host.xml file ${host_xml_file} not found"

    if ! grep -q "^ *<server name=\""${server_name}"\" group=\""${server_group}"\".*" ${host_xml_file}; then
        #
        # add to the file
        #
        local n
        n=$(last-line-containing "</server>" ${host_xml_file}) || exit 1
        if [ -z "${n}" ]; then
            # no </server>, look for <servers>
            n=$(first-line-containing "<servers>" ${host_xml_file}) || exit 1
        fi
        local line="        <server name=\"${server_name}\" group=\"${server_group}\">"
        insert-at-line ${n} "${line}" ${host_xml_file}
        insert-at-line $(expr ${n} + 1) "        </server>" ${host_xml_file}
        info "server ${server_name} of group ${server_group} added to ${host_xml_file}"
    else
        info "server ${server_name} of group ${server_group} already configured"
    fi
}

#
# gets server_name:server_group pairs
#
function remove-servers() {

    debug-arguments $@

    while [ -n "$1" ]; do
        local server_name=${1%:*}
        local server_group=${1#*:}
        remove-server ${server_name} ${server_group}
        shift
    done
}

function remove-server() {

    debug-arguments $@

    local server_name=$1
    local server_group=$2

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml

    [ -f ${host_xml_file} ] || fail "host.xml file ${host_xml_file} not found"

    local n=$(first-line-containing "<server name=\""${server_name}"\" group=\""${server_group}"\"" ${host_xml_file})
    debug "n: ${n}"

    [ -z "${n}" ] && return 0

    local tmp=$(unique-file)
    if sed ${n}',/<\/server>/d' ${host_xml_file} > ${tmp}; then
        mv ${tmp} ${host_xml_file} && info "removed server ${server_name}:${server_group} from ${host_xml_file}" || fail "failed to remove ${server_name}:${server_group} from ${host_xml_file}"
    else
        rm ${tmp}
    fi
}

#
# gets a topology string
# <server-group-name1>:<server-name1>,<server-name2>,...;<server-group-name2>:<server-name3>,<server-name4>;...
# and returns a space separated list of server group names at stdout
#
# Will fail on duplicate server group names.
#
function get-server-groups-from-topology-string() {

    debug-arguments $@

    local topology=$1

    [ -z "${topology}" ] && fail "'topology' not provided"

    local server_groups=""
    local orig_topology=${topology}

    while [ -n "${topology}" ]; do

        local sg=${topology%%\%*}

        if [[ "${topology}" =~ % ]]; then
            topology=${topology#*\%}
        else
            topology="";
        fi

        if [[ ! "${sg}" =~ : ]]; then
            fail "invalid server group specification \"${sg}\" in topology string \"${orig_topology}\""
        fi

        sg=${sg%:*}
        debug "server group: ${sg}"
        debug "topology: ${topology}"

        #
        # check for duplicates
        #

        [[ "${server_groups}" =~ ${sg} ]] && fail "duplicate server group name ${sg}"

        [ "${server_groups}" = "" ] && server_groups="${sg}" || server_groups="${server_groups} ${sg}"

    done

    echo ${server_groups}
}

#
# gets a server group name and a topology string
# <server-group-name1>:<server-name1>,<server-name2>,...;<server-group-name2>:<server-name3>,<server-name4>;...
# and returns a space separated list of server names in that server group at stdout
#
function get-servers-for-group() {

    debug-arguments $@

    local server_group_name=$1
    local topology=$2

    [ -z "${server_group_name}" ] && fail "'server_group_name' not provided"
    [ -z "${topology}" ] && fail "'topology' not provided"

    if [[ ! "${topology}" =~ ${server_group_name}: ]]; then
        echo ""
        return 0
    fi

    local servers=${topology#*${server_group_name}:}
    servers=${servers%%\%*}
    servers=${servers/,/ }
    debug "servers: ${servers}"
    echo "${servers}"
}

function compute-server-identity-secret-value() {

    debug-arguments $@
    local password=$1
    [ -z "${password}" ] && fail "'password' not provided"
    echo -n "${password}" | openssl enc -base64
}

function configure-eap-to-start-at-boot() {

    debug-arguments $@

    [ -z ${JAVA_HOME} ] && fail "previous steps failed to export JAVA_HOME"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local script_dir=/usr/lib/systemd/scripts
    local script_file=/usr/lib/systemd/scripts/jboss-host-controller

    #
    # copy the System V init script in the systemd script directory if it is not already there
    #

    if [ ! -f ${script_file} ]; then
        cp ${JBOSS_HOME}/bin/init.d/jboss-as-domain.sh ${script_file} && \
            debug "copied ${JBOSS_HOME}/bin/init.d/jboss-as-domain.sh as ${script_file}" || \
            fail "failed to copy ${JBOSS_HOME}/bin/init.d/jboss-as-domain.sh as ${script_file}"
    fi

    #
    # customize the startup script
    #
    if ! grep -q "^JBOSS_HOME=${JBOSS_HOME}" ${script_file}; then
        local tmp=$(unique-file)
        (cat << EOF
#!/bin/bash
#
# JBoss EAP ExecStart=/ExecStop= script
#

JBOSS_HOME=${JBOSS_HOME}
JBOSS_USER=root
#
# The amount of time to wait for startup
#
STARTUP_WAIT=30
#
# The amount of time to wait for shutdown
#
SHUTDOWN_WAIT=30
#
# Location to keep the console log
#
JBOSS_CONSOLE_LOG=\${JBOSS_HOME}/domain/log/console.log
[ ! -d \${JBOSS_HOME}/domain/log ] && { mkdir -p \${JBOSS_HOME}/domain/log; chown \${JBOSS_USER} \${JBOSS_HOME}/domain/log; chmod a+rx \${JBOSS_HOME}/domain/log; }

EOF
) > ${tmp}
    local tmp2=$(unique-file)
    cat ${tmp} ${script_file} >> ${tmp2}
    rm ${tmp}
    mv ${tmp2} ${script_file} && \
        info "customized systemd ExecStart= script ${script_file}" || \
        fail "failed to customize systemd ExecStart= script ${script_file}"
    fi

    #
    # set permissions
    #
    chmod a+rx ${script_file} && \
        debug "set a+rx on ${script_file}" || \
        fail "failed to chmod a+rx ${script_file}"

    #
    # create the unit file
    #

    local unit_file=/usr/lib/systemd/system/$(basename ${script_file}).service

    if [ -f ${unit_file} ]; then
        info "systemd unit file ${unit_file} already exists"
    else
        (cat << EOF
[Unit]
Description=EAP Host Controller Service
After=network.target

[Service]
Type=oneshot
ExecStart=${script_file} start
ExecStop=${script_file} stop
RemainAfterExit=yes
Environment="JAVA_HOME=${JAVA_HOME}"

[Install]
WantedBy=multi-user.target
EOF
) > ${unit_file}
        info "created systemd unit file ${unit_file}"
    fi

    if ! systemctl -q is-enabled $(basename ${unit_file}) 2>/dev/null; then
        systemctl daemon-reload && \
            info "restarted systemd" || \
            fail "failed to restart systemd"

        systemctl enable $(basename ${unit_file}) && \
            info "configured $(basename ${script_file}).service to start at boot" || \
            fail "fail to configure $(basename ${script_file}).service to start at boot"
    fi
}

#
# Connects locally or remotely and executes the given command. It needs the target instance to be up and running.
#
# arg1 - the command
# arg2 - the host:port if not local invocation (empty if local invocation)
# arg3 - username (empty if local invocation)
# arg4 - password (empty if local invocation)
#
function jboss-cli() {

    debug-arguments $@

    local command=$1
    [ -z "${command}" ] && fail "'command' not provided"

    local host_and_port=$2
    local username=$3
    local password=$4

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local connect_args;

    if [ -n "${host_and_port}" ]; then
        connect_args="--connect --controller=${host_and_port} --user=${username} --password=${password}"
    else
        connect_args="-c"
    fi

    local output
    if output=$(${JBOSS_HOME}/bin/jboss-cli.sh ${connect_args} <<EOF
${command}
EOF
); then
        # success
        debug "CLI invocation success: ${output}"
        echo ${output}
   else
        fail "failed to execute JBoss CLI ${connect_args} command: ${output}"
   fi
}