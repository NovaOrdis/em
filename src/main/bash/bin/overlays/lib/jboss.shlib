#!/bin/bash

#
# Successful installation exports the following in the environment:
#   1. a valid JBOSS_HOME
#   2. a valid JBOSS_DISTRIBUTION ("wildfly", "eap" or "jdg")

# return 0 if the installation modified state or 1 if not
#
function install-binaries() {

    debug-arguments $@

    local repository
    repository=$(get-environment-configuration "repository") || exit 1
    [ -d ${repository} ] || fail "repository directory ${repository} not accessible"

    local jboss_template_name
    jboss_template_name=$(get-environment-configuration "jboss_template") || exit 1

    local jboss_template_file=${repository}/${jboss_template_name}
    [ -f ${jboss_template_file} ] || fail "JBoss template file ${jboss_template_file} not found"

    debug "jboss template file: ${jboss_template_file}"

    export JBOSS_DISTRIBUTION=$(get-jboss-distribution "${jboss_template_file}")
    debug "exported JBOSS_DISTRIBUTION=${JBOSS_DISTRIBUTION}"

    local top_level_dir_in_archive
    top_level_dir_in_archive=$(get-top-level-dir-in-zip-archive ${jboss_template_file}) || \
        fail "failed to get the top level dir from archive ${jboss_template_file}"

    debug "top level directory in archive: ${top_level_dir_in_archive}"

    local link_name=jboss
    [ "${JBOSS_DISTRIBUTION}" = "jdg" ] && link_name=jdg

    if [ -d /opt/${top_level_dir_in_archive} ]; then
        debug "JBoss already installed (/opt/${top_level_dir_in_archive})"
        [ ! -h /opt/${link_name} ] && fail "JBoss already installed as /opt/${top_level_dir_in_archive} but /opt/${link_name} link not created"
        export JBOSS_HOME=/opt/${link_name}
        return 1;
    fi

    info "installing JBoss ..."

    local unzip_quiet="-q"
    ${verbose} && unzip_quiet=""

    info "extracting ${jboss_template_file} into /opt ..."
    (cd /opt; unzip ${unzip_quiet} ${jboss_template_file}) && \
        info "extracted ${jboss_template_file} into /opt" || \
        fail "failed to extract ${jboss_template_file} into /opt"

    top_level_dir_in_archive="/opt/${top_level_dir_in_archive}"
    debug "dir_name: ${top_level_dir_in_archive}"
    [ -d ${top_level_dir_in_archive} ] || fail "${top_level_dir_in_archive} not a directory"

    (cd /opt; ln -s $(basename ${top_level_dir_in_archive}) ${link_name}) && \
        info "linked $(basename ${top_level_dir_in_archive}) to /opt/${link_name}" || \
        fail "failed to link $(basename ${top_level_dir_in_archive}) to /opt/${link_name}"

    export JBOSS_HOME=/opt/${link_name}
    debug "exported JBOSS_HOME=${JBOSS_HOME}"
    return 0
}

#
# sends the JBoss distribution type ("wildfly", "eap", "jdg") to stdout
#
function get-jboss-distribution() {

    debug-arguments $@

    local jboss_template_file_name=$1
    [ -z "${jboss_template_file_name}" ] && fail "'jboss_template_file_name' not provided"

    if [[ "${jboss_template_file_name}" =~ wildfly ]]; then
        echo "wildfly"
    elif [[ "${jboss_template_file_name}" =~ eap ]]; then
        echo "eap"
    elif [[ "${jboss_template_file_name}" =~ datagrid ]]; then
        echo "jdg"
    else
        fail "could not determine jboss type from ${jboss_template_file_name}"
    fi
}

# return 0 if the function changed state or 1 if not
function update-user-environment-for-jboss()
{
    debug-arguments $@

    local user=$1
    local mode=$2
    local type=$3 # may be wildfly, eap, jdg
    [ -z "${user}" ] && fail "${FUNCNAME[0]}: 'name' not provided"
    [ -z "${mode}" ] && fail "${FUNCNAME[0]}: 'mode' not provided"
    [ -z "${type}" ] && type=wildfly
    [ ${type} = "wildfly" -o ${type} = "eap" -o ${type} = "jdg" ] || fail "unknown jboss type ${type}"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -d ${JBOSS_HOME} ] || fail "${JBOSS_HOME} does not exist"

    local state_changed=false

    local bashrc_file="$(get-home ${user})/.bashrc"

    debug ".bashrc file: ${bashrc_file}"

    local jboss_home_variable_name="JBOSS_HOME"
    [ "${type}" = "jdg" ] && jboss_home_variable_name="JDG_HOME"
    debug "jboss home variable name: ${jboss_home_variable_name}"

    if ! grep -q "^export ${jboss_home_variable_name}=${JBOSS_HOME}" ${bashrc_file}; then
        echo "export ${jboss_home_variable_name}=${JBOSS_HOME}" >> ${bashrc_file}
        info "${jboss_home_variable_name} set for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jb=" ${bashrc_file}; then
        echo "alias jb='cd \${${jboss_home_variable_name}}'" >> ${bashrc_file}
        info "'jb' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbb=" ${bashrc_file}; then
        echo "alias jbb='cd \${${jboss_home_variable_name}}/bin'" >> ${bashrc_file}
        info "'jbb' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbc=" ${bashrc_file}; then
        echo "alias jbc='cd \${${jboss_home_variable_name}}/${mode}/configuration'" >> ${bashrc_file}
        info "'jbc' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbl=" ${bashrc_file}; then
        echo "alias jbl='cd \${${jboss_home_variable_name}}/${mode}/log'" >> ${bashrc_file}
        info "'jbc' alias created for user ${user}"
        state_changed=true
    fi

    if ! grep -q "^alias jbprocs=" ${bashrc_file}; then
        echo "alias jbprocs='ps -ef | grep java | grep --color \"\-D\[.*\]\"'" >> ${bashrc_file}
        info "'jbprocs' alias created for user ${user}"
        state_changed=true
    fi

    ${state_changed} && return 0 || return 1
}

# return 0 if the function changed state or 1 if not
function add-a-management-user()
{
    debug-arguments $@

    local management_user_name=$1
    local management_user_password=$2
    [ -z "${management_user_name}" ] && fail "${FUNCNAME[0]}: 'management_user_name' not provided"
    [ -z "${management_user_password}" ] && fail "${FUNCNAME[0]}: 'management_user_password' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -d ${JBOSS_HOME} ] || fail "${JBOSS_HOME} does not exist"

    local state_changed=false

    #
    # relax password strength enforcement
    #
    if grep -q "^password.restriction=REJECT" ${JBOSS_HOME}/bin/add-user.properties; then
        replace-regex "^password.restriction=REJECT" "password.restriction=WARN" ${JBOSS_HOME}/bin/add-user.properties || exit 1
        info "relaxed password restrictions for add-user.sh"
        state_changed=true
    fi

    #
    # add a management user
    #
    if ! grep -q "^${management_user_name}=" ${JBOSS_HOME}/standalone/configuration/mgmt-users.properties || ! grep -q "^${management_user_name}=" ${JBOSS_HOME}/domain/configuration/mgmt-users.properties; then
        ${JBOSS_HOME}/bin/add-user.sh -r ManagementRealm -u ${management_user_name} -p "${management_user_password}" || \
            fail "failed to execute ${JBOSS_HOME}/bin/add-user.sh"
        # no need for info, add-user.sh reports at stdout
        state_changed=true
    fi

    ${state_changed} && return 0 || return 1
}

#
# Writes the actual IP address of the primary interface in all of the following (if they exist):
# standalone.conf, domain.conf, clustered.conf.
#
# return 0 if the function changed state or 1 if not
function configure-public-interface()
{
    debug-arguments $@

    local ip=$1
    local modified=false

    [ -z "${ip}" ] && fail "${FUNCNAME[0]}: 'ip' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local configuration_files="standalone.conf domain.conf clustered.conf"

    for cf in ${configuration_files}; do
        local cf_path=${JBOSS_HOME}/bin/${cf}
        if [ ! -f ${cf_path} ]; then
            info "${cf_path} does not exist, no configuration will be written in it"
        else
            local environment_variable_name=JAVA_OPTS
            [ "${cf}" = "domain.conf" ] && environment_variable_name=HOST_CONTROLLER_JAVA_OPTS

            if ! grep -q "^"${environment_variable_name}"=.*Djboss\.bind\.address=" ${cf_path}; then
                echo "" >> ${cf_path}
                echo "${environment_variable_name}=\"\${"${environment_variable_name}"} -Djboss.bind.address=${ip}\"" >> ${cf_path}
                info "configured public interface to bind to ${ip} in ${cf_path}"
                modified=true
            else
                info "${cf_path} already configured with public interface ${ip}"
            fi
        fi
    done

    ${modified} && return 0 || return 1
}

#
# Writes the actual IP address of the management interface in both standalone.conf and domain.conf file.
#
# return 0 if the function changed state or 1 if not
function configure-management-interface()
{
    debug-arguments $@

    local ip=$1
    local modified=false

    [ -z "${ip}" ] && fail "${FUNCNAME[0]}: 'ip' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local configuration_files="standalone.conf domain.conf"

    for cf in ${configuration_files}; do
        local cf_path=${JBOSS_HOME}/bin/${cf}
        if [ ! -f ${cf_path} ]; then
            info "${cf_path} does not exist, no configuration will be written in it"
        else

            local environment_variable_name=JAVA_OPTS
            [ "${cf}" = "domain.conf" ] && environment_variable_name=HOST_CONTROLLER_JAVA_OPTS

            if ! grep -q "^"${environment_variable_name}"=.*Djboss\.bind\.address\.management=" ${cf_path}; then
                echo "" >> ${cf_path}
                echo "${environment_variable_name}=\"\${"${environment_variable_name}"} -Djboss.bind.address.management=${ip}\"" >> ${cf_path}
                info "configured management interface to bind to ${ip} in ${cf_path}"
                modified=true
            else
                info "${cf_path} already configured with management interface ${ip}"
            fi
        fi
    done

    ${modified} && return 0 || return 1
}

#
# Write the actual host name into the <host> root element
#
# TODO: replace modifying xml with external property (jboss.host.name)
#
# return 0 if the function changed state or 1 if not
function configure-host.xml-host-name() {

    debug-arguments $@

    local host_name=$1

    [ -z "${host_name}" ] && fail "${FUNCNAME[0]}: 'host_name' not provided"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local host_conf_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_conf_file} ] || fail "${host_conf_file} does not exist"

    if ! grep -q "^<host name=\"${host_name}\" " ${host_conf_file}; then
            replace-regex "^\(<host name=\\\"\).*\(\\\" xmlns=.*\)" "\1"${host_name}"\2" ${host_conf_file} || exit 1
        info "set host.xml host name to '${host_name}'"
        return 0
    fi

    return 1
}

#
# Modifies the <server-groups> section of the domain controller's domain.xml based on the
# "--server-groups" command line specification
#
function configure-server-groups() {

    debug-arguments $@

    local server_groups=$1 # empty is not acceptable - we cannot have no server groups
    [ -z "${server_groups}" ] && fail "'server_groups' not provided"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local domain_xml_file=${JBOSS_HOME}/domain/configuration/domain.xml
    [ -f ${domain_xml_file} ] || fail "${domain_xml_file} does not exist"

    #
    # just a hack now, reduce the memory size so we can start it on small Amazon EC2 instances
    #


    local size=200m

    if ! grep -q "<heap size=\"${size}\"" ${domain_xml_file}; then
        replace-regex "^\(.*\)<heap size=.*$" "\1<heap size=\\\""${size}"\\\" max-size=\\\""${size}"\\\"\/>" ${domain_xml_file} || exit 1
        info "updated ${domain_xml_file}"
        return 0
    fi

    return 1
}

#
# The function configures the local host.xml with the IP address of the domain controller
#
function configure-master-domain-controller-locally() {

    debug-arguments $@

    local domain_controller_ip_address=$1
    [ -z "${domain_controller_ip_address}" ] && fail "'domain_controller_ip_address' not provided"
    local domain_controller_name=$2 # this is used for friendlier info messages only
    [ -z "${domain_controller_name}" ] && fail "'domain_controller_name' not provided"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml
    [ -f ${host_xml_file} ] || fail "${host_xml_file} does not exist"

    if grep -q "^ *<remote host=\""${domain_controller_ip_address} ${host_xml_file}; then
        info "host controller already configured as a subordinate of domain controller ${domain_controller_name} (${domain_controller_ip_address})"
        return 1
    fi

    #
    # TODO - if we need to change the domain controller IP address
    #
    if grep -q "^ *<remote host=" ${host_xml_file}; then
        fail "this subordinate host controller was already configured with a domain controller different than ${domain_controller_ip_address} - we don't handle this case yet"
    fi

    info "configuring ourselves as subordinate host controller for domain controller ${domain_controller_ip_address}"

    local changes=false

    #
    # comment out "<local/>
    #
    if grep -q "^ *<local/> *$" ${host_xml_file}; then
        replace-regex "<local\/>" "<!-- <local\/> -->" ${host_xml_file} || exit 1
        info "turned off the <local/> domain controller in ${host_xml_file}"
        changes=true
    fi

    #
    # enable the remote domain controller
    #
    if grep -q "<!-- *<remote host" ${host_xml_file}; then
        replace-regex "^\( *\)<!-- *<remote host.*$" "\1<remote host=\\\""${domain_controller_ip_address}"\\\" port=\\\"\${jboss.domain.master.port:9999}\\\" security-realm=\\\"ManagementRealm\\\"\/>" ${host_xml_file} || exit 1
        info "configured domain controller IP address ${domain_controller_ip_address} in ${host_xml_file}"
        changes=true
    fi

    ${changes} && return 0 || return 1
}

function establish-subordinate-host-controller-identity-on-domain-controller() {

    debug-arguments $@

    local domain_controller_ip_address=$1
    local domain_controller_name=$2

    [ -z "${domain_controller_ip_address}" ] && fail "'domain_controller_ip_address' not provided"
    [ -z "${domain_controller_name}" ] && fail "'domain_controller_name' not provided"

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"
    [ -z ${JAVA_HOME} ] && fail "previous steps failed to export JAVA_HOME"

    local host_controller_name=$(hostname)
    local password="${host_controller_name}_123"

    #
    # Unsafe assumption: we assume JBoss is installed in the same location on the domain controller so
    # we use the same JBOSS_HOME. This is most likely true, as we strive for homogeneous environments
    # but it may not be. If that is the case, we need to invoke remotely into the domain controller's
    # management interface using the local CLI and get the installation directory
    #

    #
    # Another unsafe assumption: we assume Java is installed in the same location. Same considerations
    # as the above apply.
    #

    local remote_jboss_home=${JBOSS_HOME}
    local remote_java_home=${JAVA_HOME}
    local remote_command="export JAVA_HOME=${remote_java_home}; ${remote_jboss_home}/bin/add-user.sh -r ManagementRealm -u ${host_controller_name} -p ${password}"
    local output
    output=$(execute-remotely "root" ${domain_controller_ip_address} ${remote_command}) || exit 1
    debug "remote execution output: ${output}"

    local server_identity_secret_value=$(compute-server-identity-secret-value ${password})
    debug "server_identity_secret_value: ${server_identity_secret_value}"

    #
    # Update host.xml with the server identity secret value. We can't CLI for the time being, server not up
    # at this point
    #
    # jboss-cli "/host=${host_controller_name}/core-service=management/security-realm=ManagementRealm/server-identity=secret:add(value=\""${server_identity_secret_value}"\")"
    #

    #
    # We have to modify host.xml directly instead ...
    #

    local host_xml_file=${JBOSS_HOME}/domain/configuration/host.xml

    [ -f ${host_xml_file} ] || fail "${host_xml_file} not found"

    if ! grep -q "${server_identity_secret_value}" ${host_xml_file}; then

        #
        # injecting server identity secret value
        #

        local line_nr
        line_nr=$(grep -n -m 1 "<\/authorization>" ${host_xml_file})
        line_nr=${line_nr%%:*}
        debug "line_nr: ${line_nr}"
        local tmp=$(unique-file)
        cat ${host_xml_file} | sed -e ${line_nr}'a\
                <server-identities>\
                    <secret value="'${server_identity_secret_value}'"/>\
                </server-identities>' > ${tmp}
        mv ${tmp} ${host_xml_file} && \
            info "inserted server identity into ${host_xml_file}" || \
            fail "failed to restore ${host_xml_file}"
    fi
}

function compute-server-identity-secret-value() {

    debug-arguments $@
    local password=$1
    [ -z "${password}" ] && fail "'password' not provided"
    echo -n "${password}" | openssl enc -base64
}

#
# Creates the underlying wiring required by the systemd startup mechanism. The startup scripts are
# named suggestively jboss-standalone or jboss-host-controller, depending on the mode JBoss is intended
# to start it (first argument "standalone" or "domain")
#
function configure-jboss-to-start-at-boot() {

    debug-arguments $@

    local mode=$1 # must be either "standalone" or "domain"
    local distribution=$2 # must be "wildfly", "eap", "jdg"
    local profile=$3 # it only makes sense for standalone, for domain profiles are associated with server groups
                     # in configuration; for standalone, it can be "" (meaning default), "ha", "full" and "full-ha"
    [ "${mode}" = "standalone" -o "${mode}" = "domain" ] || fail "'mode' must be either \"standalone\" or \"domain\" but it is \"${mode}\""
    [ "${distribution}" = "wildfly" -o "${distribution}" = "eap" -o "${distribution}" = "jdg" ] || \
        fail "invalid 'distribution' value: \"${distribution}\""

    [ -z ${JAVA_HOME} ] && fail "previous steps failed to export JAVA_HOME"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local script_file
    local script_dir=/usr/lib/systemd/scripts
    if [ "${distribution}" = "jdg" ]; then
        script_file=${script_dir}/jboss-datagrid
    else
        [ "${mode}" = "standalone" ] && \
            script_file=${script_dir}/jboss-standalone || \
            script_file=${script_dir}/jboss-host-controller
    fi

    #
    # create the System V init script in the systemd script directory if it is not already there
    #

    if [ ! -f ${script_file} ]; then

        local init_script_content
        init_script_content=$(get-customized-source-init-script-content "${distribution}" "${mode}" "${profile}") || exit 1
        echo "${init_script_content}" > ${script_file} && \
            info "wrote customized systemd ExecStart= script ${script_file}" || \
            fail "failed to write customized systemd ExecStart= script ${script_file}"
    fi

    #
    # set permissions
    #

    chmod a+rx ${script_file} && debug "set a+rx on ${script_file}" || fail "failed to chmod a+rx ${script_file}"

    #
    # create the unit file
    #

    local unit_file_name
    unit_file_name=$(basename ${script_file}) || exit 1
    unit_file_name="${unit_file_name}.service"

    local unit_file=/usr/lib/systemd/system/${unit_file_name}

    if [ -f ${unit_file} ]; then
        info "systemd unit file ${unit_file} already exists"
    else

        local description="JBoss Service"

        [ "${distribution}" = "jdg" ] && description="JBoss Datagrid Service"

        (cat << EOF
[Unit]
Description=${description}
After=network.target

[Service]
Type=oneshot
ExecStart=${script_file} start
ExecStop=${script_file} stop
RemainAfterExit=yes
Environment="JAVA_HOME=${JAVA_HOME}"

[Install]
WantedBy=multi-user.target
EOF
) > ${unit_file}
        info "created systemd unit file ${unit_file}"
    fi

    if ! systemctl -q is-enabled $(basename ${unit_file}) 2>/dev/null; then
        systemctl daemon-reload && \
            info "restarted systemd" || \
            fail "failed to restart systemd"

        systemctl enable $(basename ${unit_file}) && \
            info "configured ${unit_file_name} to start at boot" || \
            fail "fail to configure ${unit_file_name} to start at boot"
    fi
}

#
# returns at stdout the content of the customized init script to used for startup. It is usually based on
# the appropriate ${JBOSS_HOME}/bin/init.d script, depending on mode and distribution (wildfly, eap, etc).
#
function get-customized-source-init-script-content() {

    debug-arguments $@

    local distribution=$1 # must be either "wildfly", "eap", "jdg"
    local mode=$2 # must be either "standalone" or "domain"
    local profile=$3 # it only makes sense for standalone, for domain profiles are associated with server groups
                     # in configuration; for standalone, it can be "" (meaning default), "ha", "full" and "full-ha"

    [ "${mode}" = "standalone" -o "${mode}" = "domain" ] || \
        fail "'mode' must be either \"standalone\" or \"domain\" but it is \"${mode}\""
    [ "${distribution}" = "wildfly" -o "${distribution}" = "eap" -o "${distribution}" = "jdg" ] || \
        fail "'distribution' must be \"wildfly\", \"eap\" or \"jdg\" but it is \"${distribution}\""
    [ "${profile}" = "" -o "${profile}" = "ha" -o "${profile}" = "full" -o "${profile}" = "full-ha" ] || \
        fail "'profile' must be one of \"\", \"ha\", \"full\" or \"full-ha\" but it is \"${profile}\""

    local source_file

    local jboss_home_variable_name=JBOSS_HOME
    local jboss_user_variable_name=JBOSS_USER
    local jboss_config_variable_name=JBOSS_CONFIG
    local jboss_console_log_variable_name=JBOSS_CONSOLE_LOG

    if [ "${distribution}" = "eap" ]; then

        if [ "${mode}" = "domain" ]; then
            source_file=${JBOSS_HOME}/bin/init.d/jboss-as-domain.sh
        elif [ "${mode}" = "standalone" ]; then
            source_file=${JBOSS_HOME}/bin/init.d/jboss-as-standalone.sh
        else
            fail "invalid mode '${mode}'"
        fi
    elif [ "${distribution}" = "wildfly" ]; then

        if [ "${mode}" = "domain" ]; then
            fail "support for ${distribution}/${mode} NOT YET IMPLEMENTED"
        elif [ "${mode}" = "standalone" ]; then

            source_file=${JBOSS_HOME}/bin/init.d/wildfly-init-redhat.sh

            if [ ! -f ${source_file} ]; then
                #
                # try in other places
                #

                # WildFly 10.0.0
                source_file=${JBOSS_HOME}/docs/contrib/scripts/init.d/wildfly-init-redhat.sh
            fi

            [ ! -f ${source_file} ] && fail "no init file found for ${mode} ${distribution}"
        else
            fail "invalid mode '${mode}'"
        fi
    elif [ "${distribution}" = "jdg" ]; then

        jboss_home_variable_name=ISPN_SERVER_HOME
        jboss_user_variable_name=ISPN_SERVER_USER
        jboss_config_variable_name=ISPN_SERVER_CONFIG
        jboss_console_log_variable_name=ISPN_SERVER_CONSOLE_LOG

        source_file=${JBOSS_HOME}/bin/init.d/jboss-datagrid.sh
        [ ! -f ${source_file} ] && fail "no init file found for ${distribution}"

    else
        fail "invalid distribution '${type}'"
    fi

    #
    # assemble the "profile line". It only makes sense in standalone mode, in domain mode it can be empty
    # as the profiles are associated with server groups in configuration
    #
    local profile_line=""
    if [ "${distribution}" = "jdg" ]; then
        profile_line=${jboss_config_variable_name}=clustered.xml
    else
        if [ "${mode}" = "standalone" ]; then
            profile_line="${jboss_config_variable_name}=standalone"
            [ "${profile}" != "" ] && profile_line="${profile_line}-${profile}"
            profile_line="${profile_line}.xml"
        fi
    fi

    local jboss_home_variable_reference="\${${jboss_home_variable_name}}"
    local jboss_user_variable_reference="\${${jboss_user_variable_name}}"

    cat << EOF
#!/bin/bash
#
# JBoss ExecStart=/ExecStop= script
#

${jboss_home_variable_name}=${JBOSS_HOME}
${jboss_user_variable_name}=root
${profile_line}

#
# The amount of time to wait for startup
#
STARTUP_WAIT=30
#
# The amount of time to wait for shutdown
#
SHUTDOWN_WAIT=30
#
# Location to keep the console log
#
${jboss_console_log_variable_name}=${jboss_home_variable_reference}/${mode}/log/console.log
[ ! -d ${jboss_home_variable_reference}/${mode}/log ] && { mkdir -p ${jboss_home_variable_reference}/${mode}/log; chown ${jboss_user_variable_reference} ${jboss_home_variable_reference}/${mode}/log; chmod a+rx ${jboss_home_variable_reference}/${mode}/log; }

EOF

    cat ${source_file} | grep -v "^#\!\/"
}

########################################################################################################################
# CLI utilities
########################################################################################################################

#
# Connects locally or remotely and executes the given command. It needs the target instance to be up and running.
#
function jboss-cli() {

    debug-arguments $@

    local command=$1 # the command
    [ -z "${command}" ] && fail "'command' not provided"

    local host_and_port=$2 # the host:port if not local invocation (empty if local invocation)
    local username=$3 # username (empty if local invocation)
    local password=$4 # password (empty if local invocation)

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local connect_args;

    if [ -n "${host_and_port}" ]; then
        connect_args="--connect --controller=${host_and_port} --user=${username} --password=${password}"
    else
        connect_args="-c"
    fi

    local output
    if output=$(${JBOSS_HOME}/bin/jboss-cli.sh ${connect_args} <<EOF
${command}
EOF
); then
        # success
        debug "CLI invocation success: ${output}"
        echo ${output}
   else
        fail "failed to execute JBoss CLI ${connect_args} command: ${output}"
   fi
}

#
# Returns the attribute value at stdout
# If the attribute is undefined, returns empty string at stdout
# If the call is unsuccessful, the function call fails
#
function read-attribute() {

    debug-arguments $@

    local path=$1 # the resource path
    local attribute_name=$2 # the attribute name
    local host_and_port=$3 # the host:port if not local invocation (empty if local invocation)
    local username=$4 # username (empty if local invocation)
    local password=$5 # password (empty if local invocation)

    [ -z "${path}" ] && fail "'path' not provided"
    [ -z "${attribute_name}" ] && fail "'attribute_name' not provided"

    local value
    value=$(jboss-cli "${path}:read-attribute(name=${attribute_name})") || exit 1

    if ! echo "${value}" | grep -q "\"outcome\" *=> * \"success\""; then
        fail "read-attribute failed"
    fi

    debug "read-attribute invocation successful"
    value=$(echo "${value}" | sed -e 's/.*\"result\" *=> *\"\(.*\)\" }.*$/\1/')
    debug "value: ${value}"

    if [ "${value}" = "undefined" ]; then
        echo ""
    else
        echo "${value}"
    fi
}

#
# Writes the attribute value
#
function write-attribute() {

    debug-arguments $@

    local path=$1 # the resource path
    local attribute_name=$2 # the attribute name
    local attribute_value=$3 # the attribute value
    local host_and_port=$4 # the host:port if not local invocation (empty if local invocation)
    local username=$5 # username (empty if local invocation)
    local password=$6 # password (empty if local invocation)

    [ -z "${path}" ] && fail "'path' not provided"
    [ -z "${attribute_name}" ] && fail "'attribute_name' not provided"
    [ -z "${attribute_value}" ] && fail "'attribute_value' not provided"

    local output
    output=$(jboss-cli "${path}:write-attribute(name=\"${attribute_name}\",value=\"${attribute_value}\")") || exit 1
}

########################################################################################################################
# END of CLI utilities
########################################################################################################################


########################################################################################################################
# Logic that modifies XML lists based on external (command-line) specifications. Used to modify:
#
# domain.xml:
#
#   <server-groups>
#      <server-group name="G1" profile="full">
#         ...
#      </server-group>
#      <server-group name="G2" profile="full-ha">
#         ...
#      </server-group>
#      <server-group name="G3" profile="ha">
#         ...
#      </server-group>
#      <server-group name="G4" profile="full">
#         ...
#      </server-group>
#   </server-groups>
#
# host.xml:
#
#     <servers>
#        <server name="s1" group="G1" ...>
#        </server>
#        <server name="s2" group="G2" ...>
#        </server>
#        <server name="s3" group="G3" ...>
#        </server>
#        <server name="s4" group="G4" ...>
#        </server>
#        <server name="s5" group="G1" ...>
#        </server>
#     </servers>
#
########################################################################################################################

function update-server-list-in-host-xml() {

    debug-arguments $@

    local servers=$1
    local domain_controller_ip_address=$2

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    update-xml-list ${JBOSS_HOME}/domain/configuration/host.xml "servers" "server" "group" ${servers} ${domain_controller_ip_address}
}

function update-server-group-list-in-domain-xml() {

    debug-arguments $@

    local server_groups=$1
    local domain_controller_ip_address=$2

    [ -z "${server_groups}" ] && fail "no --server-groups=server-group-name:profile,... specification, cannot build a domain controller without any server groups"
    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    update-xml-list ${JBOSS_HOME}/domain/configuration/domain.xml "server-groups" "server-group" "profile" ${server_groups} ${domain_controller_ip_address}

}
#
# Gets a list content specification as string:
#
# name:second-attr,name:second-attr,name:second-attr
#
# host.xml "<servers>" example:
#   <server-name1>:<server-group-name1>,<server-name2>:<server-group-name2> ...
#
# domain.xml "<server-groups>" example:
#   <server-group-name1>:<profile-name1>, <server-group-name2>:<profile-name2>
#
#
# (...)
# and updates the list in the specified file, after applying consistency checks.
#
# Empty list content specification string is permitted, it means: clear the list.
#
function update-xml-list() {

    debug-arguments $@

    local xml_file=$1
    local list_container_element=$2
    local element=$3
    local attribute_name=$4
    local list_content_spec=$5 # empty list_content_spec is permitted
    local domain_controller_ip_address=$6 # empty domain controller is permitted

    [ -z "${xml_file}" ] && fail "'xml_file' not provided"

    local existing_elements_as_pairs
    existing_elements_as_pairs=$(get-existing-elements-from-list-as-pairs ${xml_file} ${element} "name" ${attribute_name}) || exit 1

    debug "existing elements: ${existing_elements_as_pairs}"

    local added_elements

    if [ -n "${list_content_spec}" ]; then

        #
        # there are list elements to add
        #

        local attribute_values

        attribute_values=$(get-attributes ${list_content_spec}) || exit 1

        local added_elements

        for a in ${attribute_values}; do

            debug "processing ${attribute_name} ${a}"

            #
            # check if the attribute value is valid
            #

            if ! is-valid-attribute-value ${attribute_name} ${a} ${domain_controller_ip_address} ; then
                fail "${a} is not a valid ${attribute_name}"
            fi

            local element_names=$(get-element-names-corresponding-to-attribute ${a} ${list_content_spec}) || exit 1

            debug "adding ${element} ${element_names} to ${attribute_name} ${a}"

            for n in ${element_names}; do
                debug "${element} name: ${n} ${attribute_name}: ${a}"
                add-xml-list-element ${xml_file} ${list_container_element} ${element} ${attribute_name} ${n} ${a}
                added_elements="${added_elements} ${n}:${a}"
            done
        done

        debug "added elements: ${added_elements}"
    fi

    #
    # remove the extra elements
    #

    local elements_to_remove

    for ep in ${existing_elements_as_pairs}; do
        local added=false
        for ap in ${added_elements}; do
            if [ "${ep}" = "${ap}" ]; then
                added=true;
                break;
            fi
        done

        if ! ${added}; then
            elements_to_remove="${elements_to_remove} ${ep}"
        fi
    done

    debug "elements to remove: ${elements_to_remove}"

    remove-elements ${xml_file} ${element} ${attribute_name} ${elements_to_remove}
}

#
# return at <name-value>:<attribute-value> at stdout, on multiple lines
#
function get-existing-elements-from-list-as-pairs() {

    debug-arguments $@

    local xml_file=$1
    local element=$2 # the XML element that contains the "name" and the other attribute
    local name_attribute_name=$3 # the name of the attribute that contains the name (usually "name")
    local the_other_attribute_name=$4 # the name of the attribute that contains the other piece of the pair (example "group")

    [ -z "${xml_file}" ] && fail "'xml_file' not provided"
    [ -z "${element}" ] && fail "'element' not provided"
    [ -z "${name_attribute_name}" ] && fail "'name_attribute_name' not provided"
    [ -z "${the_other_attribute_name}" ] && fail "'the_other_attribute_name' not provided"
    [ -f ${xml_file} ] || fail "${xml_file} not found"

    cat ${xml_file} | \
        grep "^ *<${element} ${name_attribute_name}=\".*\" ${the_other_attribute_name}=\".*\".*>.*" | \
        sed -e 's/.*'${name_attribute_name}'=\"\(.*\)\" '${the_other_attribute_name}'=\"\([^ ]*\)\".*$/\1:\2 /'
}

#
# Returns at stdout a space separated list containing unique attribute values extracted from the given specification
# list: <name1>:<attribute-value1>,<name2>:<attribute-value2>,...
#
function get-attributes() {

    debug-arguments $@

    local list=$1

    [ -z "${list}" ] && fail "'list' not provided"

    local orig_list=${list}
    local attributes=""

    while [ -n "${list}" ]; do

        local pair=${list%%,*}

        if [[ "${list}" =~ , ]]; then
            list=${list#*,}
        else
            list="";
        fi

        if [[ ! "${pair}" =~ : ]]; then
            fail "invalid list element pair \"${pair}\" in list \"${orig_list}\", it does not contain ':'"
        fi

        local attribute=${pair#*:}
        debug "attribute: ${attribute}"
        debug "list: ${list}"

        if [[ ! "${attributes}" =~ ${attribute}' ' ]]; then

            #
            # not a duplicate, add to the list
            #
            attributes="${attributes}${attribute} "
        fi
    done

    echo ${attributes}
}

#
# will return 0 if the attribute value is valid or 1 if not
#
function is-valid-attribute-value() {

    debug-arguments $@

    local attribute_name=$1
    local attribute_value=$2
    local domain_controller_ip_address=$3

    if [ "${attribute_name}" = "group" ]; then
        is-valid-server-group ${attribute_value} ${domain_controller_ip_address}
    elif [ "${attribute_name}" = "profile" ]; then
        [ "ha" = "${attribute_value}" -o "full-ha" = "${attribute_value}" -o "full" = "${attribute_value}" -o "default" = "${attribute_value}" ] && return 0 || return 1
    else
        fail "we don't know how to verify a '${attribute_name}' attribute value"
    fi
}

#
# will return 0 if the server group is valid (exists on the domain controller) or 1 if the server group does not exist
# on the domain controller
#
function is-valid-server-group() {

    local server_group=$1
    local domain_controller_ip_address=$2

    local output=$(jboss-cli "ls /server-group" ${domain_controller_ip_address}:9999 "admin" "admin123") || exit 1
    local server_groups=$(echo ${output} | sed -e 's/^.*ls \/server-group \(.*\) \[.*$/\1/') || exit 1
    debug "server_groups: ${server_groups}"
    local sg
    for sg in ${server_groups}; do
        [ "${sg}" = "${server_group}" ] && { debug "${server_group} is a valid server group"; return 0; }
    done
    debug "${server_group} is NOT a valid server group"
    return 1
}

#
# Given a specification list <name1>:<attribute-value1>,<name2>:<attribute-value2>,..., returns a space separated
# list containing all elements names corresponding to a specific attribute value. It coalesces duplicates.
#
function get-element-names-corresponding-to-attribute() {

    debug-arguments $@

    local attr_value=$1
    local list=$2

    [ -z "${attr_value}" ] && fail "'value' not provided"
    [ -z "${list}" ] && fail "'list' not provided"

    if [[ ! "${list}" =~ :${value} ]]; then
        echo ""
        return 0
    fi

    IFS=","
    set ${list}
    IFS=" "

    local name
    local value
    local result
    while [ -n "$1" ]; do
        name=${1%:*}
        value=${1#*:}
        shift
        debug "name: ${name}, value: ${value}"
        if [ "${attr_value}" != "${value}" ]; then
            continue;
        fi

        if [[ "${result}" =~ ${name}' ' ]]; then
            # duplicate
            continue
        fi

        result="${result}${name} "
    done

    echo ${result}
}

#
# Add the XML element to the list if it does not exist already
#
function add-xml-list-element() {

    debug-arguments $@

    local xml_file=$1
    local list_container_element=$2 # ex: servers
    local element=$3 # ex: server
    local attribute_name=$4 # ex: group
    local element_name=$5
    local attribute_value=$6

    [ -z "${xml_file}" ] && fail "'xml_file' not provided"
    [ -z "${list_container_element}" ] && fail "'container_element' not provided"
    [ -z "${element}" ] && fail "'element' not provided"
    [ -z "${attribute_name}" ] && fail "'attribute_name' not provided"
    [ -z "${element_name}" ] && fail "'element_name' not provided"
    [ -z "${attribute_value}" ] && fail "'attribute_value' not provided"

    [ -f ${xml_file} ] || fail "XML file ${xml_file} not found"

    if ! grep -q "^ *<${element} name=\""${element_name}"\" ${attribute_name}=\""${attribute_value}"\".*" ${xml_file}; then

        #
        # add to the file
        #

        local n
        n=$(last-line-containing "</${element}>" ${xml_file}) || exit 1
        if [ -z "${n}" ]; then
            # no </server>, look for <servers>
            n=$(first-line-containing "<${list_container_element}>" ${xml_file}) || exit 1
        fi
        local line="        <${element} name=\"${element_name}\" ${attribute_name}=\"${attribute_value}\">"
        insert-at-line ${n} "${line}" ${xml_file}
        insert-at-line $(expr ${n} + 1) "        </${element}>" ${xml_file}
        info "${element} ${element_name} of ${attribute_name} ${attribute_value} added to ${xml_file}"
    else
        info "${element} ${element_name} of ${attribute_name} ${attribute_value} already configured"
    fi
}

#
# gets element_name:attribute_value pairs
#
function remove-elements() {

    debug-arguments $@

    local xml_file=$1
    shift
    local element=$1
    shift
    local attribute_name=$1
    shift

    while [ -n "$1" ]; do
        local element_name=${1%:*}
        local attribute_value=${1#*:}
        remove-element ${xml_file} ${element} ${attribute_name} ${element_name} ${attribute_value}
        shift
    done
}

function remove-element() {

    debug-arguments $@

    local xml_file=$1
    local element=$2
    local attribute_name=$3
    local element_name=$4
    local attribute_value=$5

    [ -f ${xml_file} ] || fail "${xml_file} not found"

    local n=$(first-line-containing "<${element} name=\""${element_name}"\" ${attribute_name}=\""${attribute_value}"\"" ${xml_file})
    debug "n: ${n}"

    [ -z "${n}" ] && return 0

    local tmp=$(unique-file)
    if sed ${n}',/<\/'${element}'>/d' ${xml_file} > ${tmp}; then
        mv ${tmp} ${xml_file} && \
            info "removed ${element} ${element_name} ${attribute_name} ${attribute_value} from ${xml_file}" || \
            fail "failed to remove ${element} ${element_name} ${attribute_name} ${attribute_value} from ${xml_file}"
    else
        rm ${tmp}
    fi
}

########################################################################################################################
# End of Logic that modifies XML lists based on external (command-line) specifications.
########################################################################################################################

#
# configures existing server groups, adds socket-binding-group and jvm definitions.
#
function configure-server-groups() {

    debug-arguments $@

    local server_groups=$1

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local domain_xml=${JBOSS_HOME}/domain/configuration/domain.xml

    IFS=","
    set ${server_groups}
    IFS=" "

    local server_group_names
    while [ -n "$1" ]; do
        local name=${1%:*}
        shift
        [[ "${server_group_names}" =~ ${name}' ' ]] && continue;
        server_group_names="${server_group_names}${name} "
    done

    debug "server group names: ${server_group_names}"

    local name
    for name in ${server_group_names}; do

        debug "name: ${name}"

        local n

        n=$(first-line-containing "<server-group name=\"${name}\"" ${domain_xml})

        local server_group_definition=$(line-at ${n} ${domain_xml})
        debug "server group definition: ${server_group_definition}"
        local profile_name=${server_group_definition#*profile=\"}
        profile_name=${profile_name%%\"*}
        debug "profile name: ${profile_name}"

        local line_where_jvm_should_be=$(expr ${n} + 1)
        local line=$(line-at ${line_where_jvm_should_be} ${domain_xml})
        if [[ ${line} =~ '<jvm name=' ]]; then
            debug "<jvm ...> definition already present, moving onto the next server group"
            continue;
        fi

        debug "inserting jvm specification at line ${n} ..."
        local tmp=$(unique-file)
        cat ${domain_xml} | sed -e ${n}'a\
            <jvm name="default">\
                <heap size="200m" max-size="200m"/>\
            </jvm>' > ${tmp} || fail "fail to append to line ${n} in ${domain_xml}"
        diff ${tmp} ${domain_xml} > /dev/null && { rm ${tmp}; debug "no insertion was made"; return 1; } # identical files, no replacement made
        mv ${tmp} ${domain_xml} && info "added <jvm> specification at line ${n} in ${domain_xml}" || fail "failed to restore ${domain_xml}"

        #<socket-binding-group ref="full-ha-sockets"/>
        n=$(expr ${n} + 3)
        debug "inserting socket-binding-group specification at line ${n} ..."
        tmp=$(unique-file)
        cat ${domain_xml} | sed -e ${n}'a\
            <socket-binding-group ref="'${profile_name}'-sockets"/>' > ${tmp} || fail "fail to append to line ${n} in ${domain_xml}"
        diff ${tmp} ${domain_xml} > /dev/null && { rm ${tmp}; debug "no insertion was made"; return 1; } # identical files, no replacement made
        mv ${tmp} ${domain_xml} && info "added <socket-binding-group> specification at line ${n} in ${domain_xml}" || fail "failed to restore ${domain_xml}"

    done
}

#
# because there is no easy way to tell what profile a standalone JBoss instance is using, we only leave
# the relevant configuration file in place and we stash away everything else in the "archive" subdirectory
#
function archive-irrelevant-standalone-files() {

    debug-arguments $@

    local profile=$1

    [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

    local configuration_dir=${JBOSS_HOME}/standalone/configuration
    [ -d ${configuration_dir} ] || fail "directory ${configuration_dir} does not exist"

    local archive_dir=${configuration_dir}/archive

    if [ ! -d ${archive_dir} ]; then
        mkdir ${archive_dir} && info "created ${archive_dir}" || fail "failed to create ${archive_dir}"
    fi

    local configuration_file_name="standalone"
    [ -n "${profile}" ] && configuration_file_name="${configuration_file_name}-${profile}"
    configuration_file_name="${configuration_file_name}.xml"

    debug "configuration file name: ${configuration_file_name}"

    for i in ${configuration_dir}/standalone*; do

        if [ -d ${i} ]; then
            debug "ignoring directory ${i}"
            continue
        fi

        local bi=$(basename ${i})
        debug "file name: ${bi}"
        if [ "${bi}" != "${configuration_file_name}" ]; then
            mv ${i} ${archive_dir} && info "archived ${bi}" || fail "failed to move ${i} to ${archive_dir}"
        fi
    done
}

########################################################################################################################
# jboss-configuration overlay functions
########################################################################################################################

function jgroups-configuration() {

    debug-arguments $@

    local default_stack
    local initial_hosts

    while [ -n "$1" ]; do
        if [[ $1 =~ --default-stack ]]; then
            default_stack=${1:16}
        elif [[ $1 =~ --initial-hosts ]]; then
            initial_hosts=${1:16}
        fi
        shift
    done

    [ -z "${default_stack}" ] && fail "no --default-stack specified"

    debug "default_stack: ${default_stack}"
    debug "initial_hosts: ${initial_hosts}"

    #
    # configure the default stack if not already set
    #

    local current_default_stack_name
    current_default_stack_name=$(read-attribute "/subsystem=jgroups" "default-stack") || exit 1
    debug "current default stack name: ${current_default_stack_name}"

    if [ "${current_default_stack_name}" = "${default_stack}" ]; then
        info "default stack already set to '${current_default_stack_name}'"
    else
        write-attribute "/subsystem=jgroups" "default-stack" "${default_stack}"
        info "default stack set to '${default_stack}'"
    fi

    #
    # configure initial hosts as a .conf file property 'jboss.cluster.tcp.initial_hosts' if necessary
    #

    if [ -n "${initial_hosts}" ]; then

        [ -z ${JBOSS_HOME} ] && fail "previous steps failed to export JBOSS_HOME"

        local standalone_conf
        standalone_conf=${JBOSS_HOME}/bin/standalone.conf
        [ ! -f ${standalone_conf} ]  && fail "${standalone_conf} not found"

        local jboss_cluster_tcp_initial_hosts_system_property="jboss.cluster.tcp.initial_hosts"

        if grep -q "^JAVA_OPTS=\"\${JAVA_OPTS} -D${jboss_cluster_tcp_initial_hosts_system_property}=\"" ${standalone_conf}; then
            info "'${jboss_cluster_tcp_initial_hosts_system_property}' already configured in ${standalone_conf}"
        else

            #
            # resolve host names to addresses
            #
            local ips=""
            initial_hosts=${initial_hosts//,/ }
            for i in ${initial_hosts}; do
                local host_name=${i%[*}
                local postfix=${i:${#host_name}}
                local ip
                ip=$(get-internal-ip-for-name ${host_name}) || exit 1
                i=${ip}${postfix}
                debug "i: ${i}"
                [ -z "${ips}" ] && ips="${i}" || ips="${ips},${i}"
            done

            debug "initial hosts: ${ips}"

            echo "JAVA_OPTS=\"\${JAVA_OPTS} -D${jboss_cluster_tcp_initial_hosts_system_property}=${ips}\"" >> ${standalone_conf} && \
                info "'${jboss_cluster_tcp_initial_hosts_system_property}' configured in ${standalone_conf} as ${ips}" ||
                fail "failed to write ${standalone_conf}"
        fi

    fi

    #
    # swap MPING with TCPPING
    #

    #
    # if TCPPING was not installed: /subsystem=jgroups/stack=tcp/protocol=TCPPING/:read-attribute(name=type)
    #

    #
    # 
    #

}

########################################################################################################################
# END of jboss-configuration overlay functions
########################################################################################################################