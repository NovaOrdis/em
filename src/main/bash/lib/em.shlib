#!/bin/bash

#
# Global variables
#

export verbose=false
export debug=false
export dry_run=false
export help=false

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
function debug
{
    ${verbose} && echo "$@" 1>&2;
}

function debug-arguments
{
    ${verbose} && echo "${FUNCNAME[1]}($@)" 1>&2;
}

#function debug_args()
#{
#    if [ "${debug}" = "" ] || ! ${debug}; then return; fi
#
#    effective_user=`get_user_name` || exit 1
#
#    echo -n "$0 ${effective_user}@${FUNCNAME[1]}(" 1>&2;
#    while [ $# -gt 0 ]; do
#        [ "$1" = "" ] && echo -n "\"\"" 1>&2 || echo -n $1 1>&2
#        shift
#        [ $# -gt 0 ] && echo -n ", " 1>&2
#    done
#    echo ")" 1>&2;
#}

#
# Send info at stderr (not to interfere with function returns)
#
function info
{
    echo "$@" 1>&2;
}

#
# Send error information at stderr (but not exit)
#
function error
{
    echo "[error]: $@" 1>&2;
}

#
# Send error information at stderr and exit
#
function fail
{
    error "$@" && exit 1
}

#
# Process common options setting and exporting global variables (so these values are passed to sub-shells). There is no
# way (or I don't know of any way) to modify the caller's positional parameters as to remove the parameters processed
# by this function, but it sets an "args" global variable that contains the remaining parameters, so you can use that.
#
# Note that if you need to convert exported global variables back into common command line arguments (to pass them
# over ssh, for example), use 'serialize-common-arguments' function.
#
# Usage:
#           process-common-options $@
#
#           for i in ${args}; do
#               # process remaining parameters as ${i}
#           done
#
# Option Handled       Global Variable Set      Notes
#
# --verbose            export verbose=true
#
# -v                   export verbose=true
#
# --debug              export verbose=true      This should be used when we want to debug the process with a debugger
#                      export debug=true
#
# --dry-run            export dry_run=true
#
# --help               export help=true
#
function process-common-arguments
{
    args=""

    while [ $# -gt 0 ]; do
        if [ "$1" = "--verbose" -o "$1" = "-v" ]; then
            export verbose=true
        elif [ "$1" = "--debug" ]; then
            export verbose=true
            # we need to set this to pass it to sub-processes as argument
            export debug=true
        elif [ "$1" = "--dry-run" ]; then
            export dry_run=true
        elif [ "$1" = "--help" ]; then
            export help=true
        else
            [ "${args}" = "" ] && args=$1 || args="${args} $1"
        fi
        shift
    done
}

function serialize-common-arguments
{
    ${verbose} && echo "--verbose"
    ${debug} && echo "--debug"
    ${dry_run} && echo "--dry-run"
    ${help} && echo "--help"
}

#
# returns the value associate with the variable name or fail if the variable is not found
#
function config
{
    variable_name=$1
    [ "${variable_name}" = "" ] && fail "no variable name specified"

    local value="${!variable_name}"
    [ "${value}" = "" ] && fail "configuration variable '${variable_name}' has no value associated with it. Check your em configuration file"

    echo "${value}"
}

#
# the Java Wrapper
#
# Usage:
#
#       java [com.novaordis.em.]package1.package2.ClassName [main() method arguments]
#
#
function jw()
{
    debug-arguments $@

    local class_name
    local main_method_arguments

    while [ "$1" != "" ]; do
        if [ "${class_name}" = "" ]; then
            class_name=$1
        else
            [ "${main_method_arguments}" = "" ] && \
                main_method_arguments="$1" || \
                main_method_arguments="${main_method_arguments} $1"
        fi
        shift
    done

    #
    # location - in most cases, jw is run by a command, so the relative path to the etc directory is ../../etc
    #

    local etc_dir=$(dirname $0)/../../etc

    [ -d ${etc_dir} ] || fail "the em etc directory ${etc_dir} does not seem to be accessible"

    local classpath="\
$(dirname $0)/../../../../../target/em-1.0-SNAPSHOT.jar:\
${etc_dir}:\
${M2}/log4j/log4j/1.2.17/log4j-1.2.17.jar"

    ${debug} && jvm_debug_args="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006"

    class_name="com.novaordis.em.${class_name}"

    command="java -cp ${classpath} ${jvm_debug_args} ${class_name} ${main_method_arguments}"

    debug "${command}"

    ${command} && return 0 || fail "java wrapper failed"
}

#
# Returns the name of an unique file (that can be used as a temporary file). The file name path is absolute
# and can be used as returned. The function does not create the file, nor deletes it.
#
function unique-file()
{
    echo "/tmp/em-"`date +'%y%m%d%H%M%S'`"${RANDOM}"
}

#
# move <source-file> <destination-file>
#
# Overwrite the destination-file with the source-file *only if the files differ*. The default behavior is to
# remove the source file upon success.
#
# If the files are identical, fail
function move()
{
    local src=$1
    local dest=$2

    [ "${src}" = "" ] && fail "no source file specified"
    [ -f ${src} ] || fail "no such file ${src}"
    [ "${dest}" = "" ] && fail "no destination file specified"
    [ -f ${dest} ] || fail "no such file ${dest}"


    diff ${src} ${dest} > /dev/null && fail "files ${src} and ${dest} are identical, no replacement was made"
    mv ${src} ${dest} || fail "failed to move ${src} over ${dest}"
}